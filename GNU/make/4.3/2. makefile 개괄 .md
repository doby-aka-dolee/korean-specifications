# 2. makefile 개괄 - _An Introduction to Makefiles_

*make*를 실행시켰을 때 *make*는 *makefile*에 적힌대로 작업을 실행해나갑니다.
때문에 커맨드라인에서 *make*를 타이핑하고 엔터를 눌러 실행시키기 전에 *makefile*이라는 파일을 먼저 작성해놓아야 합니다.
일반적으로는 여기에 프로그램의 컴파일이나 링크에 관련된 내용들이 들어갑니다.

이번 장에서는 8개의 C 소스코드 파일들과 3개의 헤더파일로 텍스트편집기 프로그램을 컴파일/링크하는 예제 *makefile*을 작성해 볼 것입니다.
또 컴파일/링크 작업 뿐만 아니라 (명시적인 호출이 있을 경우) 그 외 다양한 작업들이 실행되도록 *makefile*을 기술할 수도 있는데, 대표적으로 오브젝트 파일같은 필요없는 파일들을 삭제하는 작업 등이 있습니다.
예제 *makefile*을 작성하면서 이러한 작업을 기술하는 방법도 다루어보도록 하겠습니다.
이에 대해 보다 자세한 정보를 원하시면 [Complex Makefile](https://www.gnu.org/software/make/manual/make.html#Complex-Makefile)를 살펴보시기 바랍니다.

*make*가 텍스트편집기 프로그램을 재컴파일하는 경우 수정사항이 있는 C 소스코드 파일들은 모두 재컴파일되어야 합니다.
헤더파일이 수정되었다면 그 헤더파일을 인클루드하는 모든 C 소스코드 파일들도 재컴파일 되어야겠죠.
각각의 컴파일 작업은 소스코드 파일 하나당 오브젝트 파일 하나를 생성할 것입니다.
그리고 소스코드 파일이 하나라도 재컴파일되었다면, 즉 오브젝트 파일이 하나라도 재생성되었다면 모든 오브젝트 파일들이 링크되어 새로운 실행파일(텍스트편집기 프로그램)을 만들어내게 됩니다.
이 때 링크되는 오브젝트 파일들은 재생성되었는지의 여부를 따지지 않습니다.
새로 재생성된 오브젝트 파일이든 이전 컴파일 과정에서 생성되었던 오브젝트 파일이든 상관 없이 모든 오브젝트 파일들이 모여 링크됩니다.

## 2.1 규칙(Rule)의 구조 - What a Rule Looks Like
일반적으로 *makefile*은 아래와 같은 구조의 규칙(Rule)들로 이루어져 있습니다.
```
target … : prerequisites …
        recipe
        …
        …
```
*타겟(target)* 은 보통 해당 규칙의 실행으로 인해 만들어지는 파일의 이름입니다. 대표적으로 실행파일이나 오브젝트 파일의 이름이 타겟이 됩니다.
또 어떤 경우는 단순히 실행되어야 할 작업이나 명령의 이름이 타겟이 될 수도 있습니다. '*clean*' 같은 작업이 대표적인 예입니다 ([Phony Targets](https://www.gnu.org/software/make/manual/make.html#Phony-Targets) 참고).

*전제조건(prerequisite)* 은 타겟을 생성 할 때 그 재료로 사용되는 파일입니다. 보통 하나의 타겟 당 여러개의 전제조건들을 가집니다.
전제조건과 관련하여 '의존하다(depend)' 라는 표현도 쓰이는데 '타겟이 전제조건에 의존한다' 와 같이 쓰입니다.
때문에 전제조건을 의존성(dependency)이라고 부르는 경우도 있습니다.

*레시피(recipe)* 는 *make*가 실제로 실행시키는 작업 혹은 명령어들입니다.
이 명령어들은 줄 하나에 쭉 나열되듯이 작성하여도 되고 여러 줄에 나누어서 줄 하나 당 하나의 명령어를 쓰듯이 작성하여도 되니다.
다만 각각의 줄 앞에는 무조건 탭 문자가 와야 합니다. 많이들 빼먹고 실수하는 부분이 꼭 기억해두세요.
혹여 탭 문자가 아닌 다른 문자를 레시피의 접두어로 쓰고 싶다면 *RECIPEPREFIX* 변수를 다른 문자로 설정하면 됩니다.
자세한 내용은 [Special Variables](https://www.gnu.org/software/make/manual/make.html#Special-Variables)을 참고해주세요.

레시피는 대게 전제조건에 수정이력이 있을 경우 실행되며 타겟을 생성하는 역할을 합니다.
다만 이 때 전제조건의 존재가 필수적인 것은 아닙니다.
대표적으로 '*clean*' 이라는 규칙의 경우 전제조건 없이 타겟과 레시피만으로 이루어져 있습니다.

이를 종합하면 결국 *규칙(rule)* 은 타겟 파일을 어느 시점에 어떻게 재생성하는지를 규정한다는 것을 알 수 있습니다.
그리고 *make*는 전제조건 파일들에 대하여 레시피를 적용 및 실행시킴으로써 타겟 파일을 생성하거나 업그레이드합니다.
물론 앞서 말했듯이 타겟 파일의 재생성 뿐만 아니라 *clean* 같은 특정 작업 혹은 명령의 동작을 규정할 수도 있습니다.
보다 자세한 내용은 [Writing Rules](https://www.gnu.org/software/make/manual/make.html#Rules)을 참고해주세요.

위에서 규칙에 관해서만 언급했지만 *makefile*에는 규칙 말고도 다른 요소들이 들어갈 수도 있습니다.
하지만 규칙들만 잘 써도 충분히 잘 동작하는 *makefile*을 만들 수 있으며 다른 요소들에 대해서는 이후의 장들에서 살펴볼 예정입니다.
또 이번 장의 예제에서는 규칙들도 최대한 간략한 형태로 기술할 예정입니다.
실제 현업에서 쓰이는 *makefile*의 경우 이 예제보다는 복잡하겠지만, 기본적인 골격이나 형태는 대동소이할 것입니다.

## 2.2 간단한 makefile 작성해보기 - A Simple Makefile
이번 절에서는 본격적으로 간단한 예제 *makefile*을 작성해보도록 하겠습니다.
이 예제 *makefile*은 *edit*이라는 이름의 실행파일을 생성하는 것을 목적으로 합니다.
실행파일은 8개의 오브젝트 파일에 의존성을 가지고 또 이 8개의 오브젝트 파일들은 각각 8개의 C 소스코드 파일들과 3개의 헤더파일에 의존성을 가집니다.

8개의 C 소스코드 파일들은 모두 *defs.h* 를 인클루드하고 있고
*command.h*는 편집 명령어(command)와 관련된 소스코드 파일들만이, *buffer.h*는 편집기의 버퍼를 다루는 저수준 작업을 수행하는 소스코드 파일들만이 인클루드합니다.

```
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
```
맨 첫 줄의 *edit* 이라는 이름의 타겟이 있는 규칙을 보면 긴 줄을 백슬래쉬/개행문자로 나눈 것을 볼 수 있을 것입니다.
백슬래쉬/개행문자 조합을 사용해서 줄을 나눌 경우 *make*는 이를 한 줄로 인식하지만 개발자인 우리의 눈으로 볼 때에는 가독성이 훨씬 좋아집니다.
보다 자세한 내용은 [Splitting Long Lines](https://www.gnu.org/software/make/manual/make.html#Splitting-Lines)을 참고해주세요.

이 *makefile*로 *edit*이라는 이름의 실행파일을 만들어내려면 아래의 명령어를 사용하면 되고,
```
make
```

실행파일과 모든 오브젝트 파일들을 지워서 작업 디렉토리를 정리하고 싶다면 다음 명령어를 사용하면 됩니다.
```
make clean
```

이제 위 예제에서 타겟, 전제조건, 레시피가 각각 무엇인지 알아보도록 하겠습니다.
우선 실행 파일인 '*edit*'과 '*main.o*', '*kbd.o*' 등의 오브젝트 파일들이 타겟이 됩니다.
'*main.c*', '*defs.h*' 등의 파일들은 전제조건이 되는데, '*.o*' 파일들의 경우 타겟이면서 동시에 전제조건이기도 하다는 것을 알 수 있습니다.
마지막으로 '*cc -c main.c*', '*cc -c kbd.*' 같은 명렁행들이 레시피가 됩니다.

타겟이 파일인 경우, 해당 타겟의 전제조건 중 수정된 파일이 하나라도 있다면 이 타겟 파일은 재컴파일되거나 재링크되어야 합니다.
물론 그 전에 전제조건 중 재생성될 수 있는 파일이 있다면 그 파일이 먼저 업데이트되어야 합니다.
위 예제 *makefile*에서의 예를 보자면 우선 *edit* 파일이 8개의 오브젝트 파일에 의존하기 때문에 오브젝트 파일 중 하나라도 수정된 파일이 있다면 재링크가 발생할 것이며,
*main.o* 파일의 경우 소스코드 파일인 *main.c* 와 헤더파일인 *defs.h* 에 의존하기 때문에 두 파일 중 하나라도 수정된 이력이 있다면 재컴파일될 것입니다.

레시피는 타겟과 전제조건의 다음 행부터 위치하며 타겟 파일을 어떻게 업데이트해야 하는가를 기술합니다.
레시피의 각 행의 맨 앞부분에는 탭 문자를 꼭 넣어주어야 하는데 *.RECIPEPREFIX* 변수에 다른 문자를 설정하면 해당 문자로 레시피 접두어를 바꿀 수 있습니다([Special Variables](https://www.gnu.org/software/make/manual/make.html#Special-Variables) 참고).
또 *make* 는 레시피를 호출하기만 할 뿐 레시피가 정확히 어떤 동작을 하는지는 알 수 없습니다. 때문에 타겟 파일이 제대로 업데이트되도록 개발자들이 레시피를 정확히 작성하는 것이 중요합니다.

타겟 '*clean*' 의 경우 파일이 아니라 단순히 특정 작업의 이름일 뿐입니다.
명시적인 호출이 있는 경우가 아니고서는 이 작업을 실행시킬 필요가 거의 없기 때문에 이런 작업명들이 다른 규칙의 전제조건으로 쓰이는 경우는 없다시피 합니다.
결국 위와 같이 단순히 작업의 이름을 타겟으로 하는 규칙의 경우 명시적인 호출이 있을 때에만 그 레시피가 실행됩니다.
또 이러한 타겟은 전제조건을 가지지도 않습니다. 다른 규칙의 전제조건이 되지 않을 뿐 아니라 자기 자신도 그 어떠한 전제조건을 가지지 않는 것입니다.
즉 다른 규칙들과 그 어떠한 상호작용도 하지 않고 그저 명시적인 호출이 있을 때 레시피들을 실행시키는 것이 목적인 타겟이 됩니다.
이와 같이 타겟이 파일이 아니고 단순히 어떤 작업의 이름인 타겟을 *가짜 타겟(phony target)* 이라고 부릅니다.
보다 자세한 정보는 [Phony Targets](https://www.gnu.org/software/make/manual/make.html#Phony-Targets)에서 찾으실 수 있습니다.
그리고 혹 여기까지 차근차근 실습을 해 봤다면 종종 레시피의 *rm* 커맨드에서 에러가 나오는 경우를 발견했을 수도 있을 것입니다.
이러한 에러를 무시하는 방법을 찾으신다면 [Errors in Recipes](https://www.gnu.org/software/make/manual/make.html#Errors)를 참고하시기 바랍니다.

## 2.3 make 동작 방식과 makefile - How *make* Processes a Makefile
*make*는 기본적으로 *makefile*에 나타나는 첫 타겟을 먼저 실행시킵니다. 다만 이 때 '.'으로 시작하는 타겟은 제외됩니다.
이 타겟을 *기본목표(default goal)* 라고 부릅니다.
여기에서 *목표(goal)* 란 *make* 가 궁극적으로 업데이트시키고자 하는 타겟입니다.
물론 이러한 목표 혹은 기본목표를 재정의할 수도 있습니다. 커맨드라인을 사용할 수도 있고 *.DEFAULT_GOAL* 이라는 특수변수를 사용할 수도 있는데
각각 [Arguments to Specify the Goals](https://www.gnu.org/software/make/manual/make.html#Goals), [Other Special Variables](https://www.gnu.org/software/make/manual/make.html#Special-Variables)에서 찾아볼 수 있습니다.

이전 절에서의 예제에서 *기본목표*는 *edit* 이라는 실행파일이었습니다.
예제 *makefile* 을 다시 보시면 *edit* 타겟이 파일의 맨 첫 줄에 위치함을 볼 수 있을 것입니다.

그래서 커맨드라인에서 다음 명령어를 입력한다면,
```
make
```
*make* 는 현재 디렉토리에서 *makefile* 을 찾아 읽고 첫 번째 규칙부터 실행을 시작할 겁니다.
위 예제에서의 첫 번째 규칙은 *edit* 을 리링크하는 것인데 앞서 언급했듯 *edit* 을 리링크하기 전에 *edit* 이 의존하고 있는 전제조건들에 대한 규칙을 먼저 실행해야 합니다.
*edit* 의 전제조건은 8개의 오브젝트 파일들인데 각 오브젝트 파일이 타겟이 되는 규칙들이 명시되어 있기 때문에 해당 규칙들이 먼저 실행됩니다.
*make* 는 각 오브젝트 파일들에 대한 규칙을 실행시키기 위하여 우선 오브젝트 파일이 존재하는지 검사합니다.
만약 해당 오브젝트 파일이 존재하지 않는다면 바로 레시피를 실행시켜 재컴파일을 진행합니다.
오브젝트 파일이 존재한다면 오브젝트 파일과 전제조건의 소스코드 파일, 헤더파일의 생성시각을 비교합니다.
만약 전제조건 파일들 중 하나라도 타겟인 오브젝트 파일보다 생성시각이 최근이라면 마찬가지로 재컴파일을 진행합니다.

위에서 *기본목표*는 *edit* 하나 뿐이었음에도 불구하고 총 9개의 규칙이 실행되었습니다.
이는 *edit*을 제외한 8개 규칙들의 타겟이 *기본목표*인 *edit* 의 전제조건으로 명시되었기 때문입니다.
만약 특정 규칙이 *기본목표*의 전제조건으로 명시되지 않거나, *기본목표*에 의존하는 그 어떤 타겟에도 전제조건으로 명시되지 않는다면 그 규칙은 *make clean* 과 같이 명시적으로 호출되지 않는 이상 절대 실행되지 않을 것입니다.

오브젝트 파일을 재컴파일 하기 전에 *make* 는 소스코드 파일이나 헤더파일 같은 전제조건들을 먼저 업데이트하려고 합니다.
하지만 위의 예제 *makefile* 에서는 '*.c*' 나 '*.h*' 파일이 타겟으로 쓰인 규칙이 없기 때문에 *make*는 소스코드 파일이나 헤더파일에 대한 규칙이 없다고 판단하고 아무 일도 하지 않습니다.
아 물론 Bison 이나 Yacc 같은 소스코드 자동생성 툴을 사용하는 경우에는 소스코드 파일이나 헤더파일도 재생성됩니다. 당연히 그에 대한 적절한 규칙을 미리 작성해두어야겠지만요.

오브젝트 파일들에 대한 재컴파일 작업이 끝나면 마지막으로 *make* 는 *edit* 실행파일에 대한 리링크 여부를 결정하게 됩니다.
만약 *edit* 파일이 존재하지 않거나 오브젝트 파일들 중 하나라도 *edit* 파일보다 최근에 생성된 파일이 있다면 *make* 는 모든 오브젝트 파일을 리링크시켜 *edit* 실행파일을 재생성시킵니다.
참고로 만약 위에서 오브젝트 파일이 하나라도 재컴파일되었었다면 그 시점에서 해당 오브젝트 파일이 *edit* 파일보다 최근에 생성된 것이 되므로 무조건 리링크가 수행되게 됩니다.

마지막으로 간단한 예로 이 절을 마무리하겠습니다.
만약 제가 *insert.c* 파일을 수정하고 *make* 를 실행시킨다면 *make* 는 *insert.c* 를 재컴파일하여 *insert.o* 파일을 만들고 곧이어 모든 오브젝트 파일들을 재링크하여 *edit* 이라는 실행파일을 만들어낼 것입니다.
또 만약 제가 *command.h* 라는 파일을 수정하고 *make* 를 실행시킨다면 *make* 는 *kbd.o*, *command.o*, *files.o* 를 재컴파일하여 만들고 다시 모든 오브젝트 파일들을 재링크하여 *edit* 이라는 실행파일을 만들 것이고요.
쉽죠?

## 2.4 - Variables Make Makefiles Simpler

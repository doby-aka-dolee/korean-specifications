# 2. makefile 개괄 - _An Introduction to Makefiles_

*make* 를 실행시키기 위해서는 *makefile* 이라는 파일을 먼저 작성해놓아야 합니다.
보통 프로그램의 컴파일이나 링크에 관한 내용들이 들어가게 되는데 *make* 는 이한 설정내용들을 읽어들여 이에 따라 작업을 실행해나갑니다.

이번 장에서는 간단한 예제 *makefile* 을 만들어봄으로써 *makefile* 의 기본적인 개념들을 살펴보겠습니다.
이 *makefile* 의 목표는 C언어로 작성된 텍스트편집기 프로그램을 컴파일하는 것인데, 총 8개의 소스코드 파일과 3개의 헤더파일을 컴파일하고 링크하는 과정을 통해 실행파일을 만들어낼 예정입니다.
그리고 더불어 단순히 컴파일이나 링크하는 작업 외에도 특수한 작업들이 실행되도록 하는 방법도 알아보겠습니다.
이러한 특수한 작업들의 경우 *make* 를 실행시킬 때 커맨드라인 인자를 이용해 명시적인 호출을 해 주어야 하는데,
보다 자세한 정보는 [Complex Makefile](https://www.gnu.org/software/make/manual/make.html#Complex-Makefile) 에서 찾으실 수 있습니다.

*make* 로 우리 예제 프로그램인 텍스트편집기 프로그램을 재컴파일한다고 해 봅시다.
이 때 이전 컴파일 시점 이후부터 수정된 적이 없는 소스코드 파일들은 다시 컴파일할 필요가 없지만 수정사항이 있는 소스코드 파일들은 재컴파일해야 합니다.
만약 헤더파일이 수정되었다면 그 헤더파일을 인클루드하는 모든 소스코드 파일들도 재컴파일해야겠죠.
이 컴파일 작업은 소스코드 파일 하나당 오브젝트 파일 하나를 생성하게 되고,
오브젝트 파일이 하나라도 재생성되었다면 모든 오브젝트 파일들이 링크되어 새로운 실행파일(텍스트편집기 프로그램)을 만들어내게 됩니다.
이 때 링크되는 오브젝트 파일들은 이번에 재생성된 것이든 이전 컴파일 때부터 남아있던 것이든 상관 없이 현재 존재하는 모든 오브젝트 파일들이 모여 링크됩니다.

## 2.1 규칙(Rule)의 구조 - What a Rule Looks Like
일반적으로 *makefile*은 아래와 같은 구조의 규칙(Rule)들로 이루어져 있습니다.
```
target … : prerequisites …
        recipe
        …
        …
```
*타겟(target)* 은 보통 해당 규칙의 실행으로 인해 만들어지는 파일의 이름인 경우가 많습니다. 대표적으로 실행파일이나 오브젝트 파일의 이름이 타겟이 됩니다.
또 어떤 경우는 단순히 실행되어야 할 작업이나 명령의 이름이 타겟이 될 수도 있는데 '*clean*' 같은 작업이 대표적인 예입니다 ([Phony Targets](https://www.gnu.org/software/make/manual/make.html#Phony-Targets) 참고).

*전제조건(prerequisite)* 은 기본적으로 타겟을 생성할 때 그 재료로 사용되는 파일들을 의미합니다.
타겟 하나 당 여러개의 전제조건을 가질 수 있는데 실제로 이렇게 다수의 전제조건을 갖는 경우가 많습니다.
전제조건과 관련하여 '의존하다(depend)' 라는 표현도 쓰이는데 '타겟이 전제조건에 의존한다' 와 같이 쓰입니다.
때문에 전제조건을 의존성(dependency)이라고 부르는 경우도 있습니다.

*레시피(recipe)* 는 *make*가 실제로 실행시키는 작업으로 보통 쉘 명령어로 이루어져 있습니다.
이 명령어들은 한 줄에 쭉 이어서 작성해도 되고 여러 줄에 걸쳐 한 줄당 하나의 명령어를 쓰듯이 작성하여도 됩니다.
다만 각각의 줄 앞에는 무조건 탭 문자가 와야 하는데 많이들 빼먹고 실수하는 부분이니 꼭 기억해두세요.
혹여 탭 문자가 아닌 다른 문자를 레시피의 접두어로 쓰고 싶다면 *RECIPEPREFIX* 변수를 다른 문자로 설정하면 됩니다 ([Special Variables](https://www.gnu.org/software/make/manual/make.html#Special-Variables) 참고).

레시피는 대게 전제조건 파일들 중 수정이 있는 파일이 있을 경우 실행되며 보통 타겟을 생성하는 역할을 합니다.
이 때 전제조건이 필수적으로 있어야 하는 것은 아닌데,
대표적으로 '*clean*' 이라는 규칙의 경우 전제조건 없이 타겟과 레시피만으로 이루어져 있습니다.

이를 종합하면 결국 *규칙(rule)* 은 타겟 파일을 어느 시점에 어떻게 재생성하는지를 규정한다는 것을 알 수 있습니다.
그리고 *make*는 전제조건 파일들에 레시피를 적용 및 실행시킴으로써 타겟 파일을 생성하거나 업데이트합니다.
물론 앞서 말했듯이 타겟 파일의 재생성 뿐만 아니라 *clean* 같은 특정 작업의 동작을 규정할 수도 있습니다.
보다 자세한 내용은 [Writing Rules](https://www.gnu.org/software/make/manual/make.html#Rules)을 참고해주세요.

위에서는 규칙에 관해서만 언급했지만 *makefile*에는 규칙 말고도 다양한 요소들이 있습니다.
하지만 규칙만 잘 써도 충분히 괜찮은 *makefile*을 만들 수 있으니 이번 장에서는 규칙만 살펴보고 보다 다양한 다른 요소들에 대해서는 이후의 장들에서 살펴보겠습니다.
또 이번 장의 예제에서는 규칙들도 최대한 간략한 형태로 기술할 예정입니다.
실제 현업에서 쓰이는 *makefile*의 경우 이 예제보다는 복잡하겠지만, 기본적인 골격이나 형태는 대동소이할 것입니다.

## 2.2 간단한 makefile 작성해보기 - A Simple Makefile
이번 절에서는 본격적으로 위에서 말한 예제 *makefile*을 작성해보도록 하겠습니다.
이 예제 *makefile*은 *edit*이라는 이름의 실행파일을 만드는 것을 목적으로 하는데,
이 *edit* 은 8개의 오브젝트 파일에 의존성을 가지고 또 이 8개의 오브젝트 파일들은 각각 8개의 소스코드 파일들과 3개의 헤더파일에 의존성을 가집니다.

각 소스코드 파일마다 인클루드하는 헤더파일에도 차이가 있는데
*defs.h* 의 경우 8개의 소스코드 파일 전부가 인클루드하고 있고
*command.h* 는 편집 명령어(command)와 관련된 소스코드 파일들만이, *buffer.h* 는 편집기의 버퍼를 다루는 저수준 작업을 수행하는 소스코드 파일들만이 인클루드하고 있습니다.
말로 설명하니 어려워보이는데 아마 다음 *makefile* 예제를 보면 쉽게 이해할 수 있을 겁니다.

```
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
```
맨 첫 줄의 *edit* 이라는 이름의 타겟이 있는 규칙을 보면 줄의 마지막에 백슬래쉬가 있습니다.
이렇게 줄의 마지막에 백슬래쉬를 넣으면 *make* 는 이 줄과 다음 줄을 합쳐서 한 줄로 인식하는데 개발자인 우리의 눈으로 볼 때에는 가독성이 훨씬 좋아지죠.
기억해두시면 줄이 길어질 때 유용하게 사용할 수 있을 겁니다.
보다 자세한 내용은 [Splitting Long Lines](https://www.gnu.org/software/make/manual/make.html#Splitting-Lines)을 참고해주세요.

이 *makefile*로 *edit*이라는 이름의 실행파일을 만들어내려면 아래의 명령어를 사용하면 되고,
```
make
```

실행파일과 모든 오브젝트 파일들을 지워서 작업 디렉토리를 정리하고 싶다면 다음 명령어를 사용하면 됩니다.
```
make clean
```

이제 위 예제에서 타겟, 전제조건, 레시피가 각각 무엇인지 알아보도록 하겠습니다.
우선 실행 파일인 '*edit*'과 '*main.o*', '*kbd.o*' 등의 오브젝트 파일들이 타겟이 됩니다.
'*main.c*', '*defs.h*' 등의 파일들은 전제조건이 되는데, '*.o*' 파일들의 경우 타겟이면서 동시에 전제조건이기도 하다는 것을 알 수 있습니다.
마지막으로 '*cc -c main.c*', '*cc -c kbd.*' 같은 명렁행들이 레시피가 됩니다.

타겟이 파일인 경우, 해당 타겟의 전제조건 중 수정된 파일이 하나라도 있다면 이 타겟 파일은 재컴파일되거나 재링크되어야 합니다.
물론 그 전제조건 중 재생성되어야 하는 파일이 있다면 그 전제조건 파일이 먼저 재생성되어야 할 것이고요.
위 예제 *makefile*에서의 예를 보자면 우선 *edit* 파일이 8개의 오브젝트 파일에 의존하기 때문에 오브젝트 파일 중 하나라도 수정된 파일이 있다면 재링크가 발생할 것이며,
*main.o* 파일의 경우 소스코드 파일인 *main.c* 와 헤더파일인 *defs.h* 에 의존하기 때문에 두 파일 중 하나라도 수정된 이력이 있다면 재컴파일되어야 할 것입니다.
여기서 *main.o* 가 *edit* 의 전제조건이기 때문에 *main.o* 의 재컴파일이 *edit* 의 재링크보다 먼저 일어날 것이고요.

레시피는 타겟과 전제조건의 다음 행부터 위치하며 타겟 파일을 어떻게 업데이트(재생성)해야 하는가를 기술합니다.
레시피의 각 행의 맨 앞부분에는 탭 문자를 꼭 넣어주어야 하는데 *.RECIPEPREFIX* 변수에 다른 문자를 설정하면 해당 문자로 레시피 접두어를 바꿀 수 있습니다([Special Variables](https://www.gnu.org/software/make/manual/make.html#Special-Variables) 참고).
또 *make* 는 레시피를 호출하기만 할 뿐 레시피가 정확히 어떤 동작을 하는지는 알 수 없다는 것을 명심해야 합니다.
때문에 타겟 파일이 제대로 업데이트되도록 개발자들이 레시피를 정확히 작성하는 것이 중요합니다.

타겟 '*clean*' 의 경우 위의 다른 타겟들과 다르게 타겟의 이름이 파일명이 아닙니다. *clean* 이라는 파일을 나타내는 것이 아닌 거죠.
여기에서 *clean* 은 그냥 특정 작업에 붙인 이름일 뿐입니다.
이 장의 초반에 일반적이지 않은 작업들을 실행시키는 경우도 있다고 언급했었는데 기억하시나요? 이 *clean* 이라는 규칙이 그 대표적인 작업입니다.
명시적인 호출이 있는 경우가 아니고서는 이런 작업을 실행시킬 필요가 거의 없기 때문에 이런 타겟들이 다른 규칙의 전제조건으로 쓰이는 경우는 거의 없다시피 합니다.
결국 위와 같이 단순히 작업의 이름을 타겟으로 하는 규칙의 경우 명시적인 호출이 있을 때에만 그 레시피가 실행됩니다.
또 이러한 타겟은 보통 전제조건을 가지지도 않습니다. 즉 다른 규칙의 전제조건이 되지 않을 뿐 아니라 자기 자신도 그 어떠한 전제조건을 가지지 않는 것입니다.
결국 다른 규칙들과 그 어떠한 상호작용도 하지 않고 그저 명시적인 호출이 있을 때 레시피들을 실행시키는 것만이 목적인 타겟이 됩니다.
이와 같은 타겟을 *가짜 타겟(phony target)* 이라고 부릅니다.
보다 자세한 정보는 [Phony Targets](https://www.gnu.org/software/make/manual/make.html#Phony-Targets)에서 찾으실 수 있습니다.
그리고 혹 여기까지 차근차근 실습을 해 봤다면 종종 레시피의 *rm* 커맨드에서 에러가 나오는 경우를 발견했을 수도 있을 텐데,
이러한 에러를 무시하는 방법을 찾으신다면 [Errors in Recipes](https://www.gnu.org/software/make/manual/make.html#Errors)를 참고하시기 바랍니다.

## 2.3 *make* 는 *makefile* 을 어떻게 실행시킬까 - How *make* Processes a Makefile
*make*는 기본적으로 *makefile*에 나타나는 첫 타겟을 먼저 실행시키는데 이 타겟을 *기본목표(default goal)* 라고 부릅니다.
다만 이 때 '.'으로 시작하는 타겟은 제외됩니다.
여기에서 *목표(goal)* 란 *make* 가 궁극적으로 업데이트(재생성)하고자 하는 타겟을 의미합니다.
물론 이러한 목표 혹은 기본목표를 재정의할 수도 있습니다. 커맨드라인을 사용할 수도 있고 *.DEFAULT_GOAL* 이라는 특수변수를 사용할 수도 있는데
각각 [Arguments to Specify the Goals](https://www.gnu.org/software/make/manual/make.html#Goals), [Other Special Variables](https://www.gnu.org/software/make/manual/make.html#Special-Variables)에서 찾아볼 수 있습니다.

이전 절에서의 예제에서 *기본목표*는 *edit* 이라는 실행파일이었습니다.
예제 *makefile* 을 다시 보면 *edit* 타겟이 파일의 맨 첫 줄에 위치함을 볼 수 있을 것입니다.

그래서 커맨드라인에서 다음 명령어를 입력한다면,
```
make
```
*make* 는 현재 디렉토리에서 *makefile* 을 찾아 읽고 첫 번째 규칙부터 실행을 시작할 겁니다.
위 예제에서의 첫 번째 규칙은 *edit* 을 리링크하는 것인데 앞서 언급했듯 *edit* 을 리링크하기 전에 *edit* 이 의존하고 있는 전제조건들에 대한 규칙을 먼저 실행해야 합니다.
*edit* 의 전제조건은 8개의 오브젝트 파일들인데 각 오브젝트 파일에 대한 규칙들이 명시되어 있기 때문에 해당 규칙들이 먼저 실행됩니다.
*make* 는 각 오브젝트 파일들에 대한 규칙을 실행시키기 위하여 우선 오브젝트 파일이 존재하는지 검사합니다.
만약 해당 오브젝트 파일이 존재하지 않는다면 바로 레시피를 실행시켜 재컴파일을 진행합니다.
오브젝트 파일이 존재한다면 오브젝트 파일과 전제조건의 소스코드 파일, 헤더파일의 생성시각을 비교하고
전제조건 파일들 중 하나라도 타겟인 오브젝트 파일보다 생성시각이 최근이라면 마찬가지로 재컴파일을 진행합니다.

위에서 *기본목표*는 *edit* 하나 뿐이었음에도 불구하고 총 9개의 규칙이 실행되었습니다.
이는 *edit*을 제외한 8개 규칙들의 타겟이 *기본목표*인 *edit* 의 전제조건으로 명시되었기 때문입니다.
만약 특정 규칙이 *기본목표*의 전제조건으로 명시되지 않거나, *기본목표*에 의존하는 그 어떤 타겟에도 전제조건으로 명시되지 않는다면 그 규칙은 *make clean* 과 같이 명시적으로 호출되지 않는 이상 절대 실행되지 않을 것입니다.

오브젝트 파일을 재컴파일 하기 전에 *make* 는 소스코드 파일이나 헤더파일 같은 전제조건들을 먼저 업데이트하려고 시도합니다.
하지만 위의 예제 *makefile* 에서는 '*.c*' 나 '*.h*' 파일이 타겟으로 쓰인 규칙이 없기 때문에 *make*는 소스코드 파일이나 헤더파일에 대한 규칙이 없다고 판단하고 아무 일도 하지 않습니다.
아 물론 Bison 이나 Yacc 같은 소스코드 자동생성 툴을 사용하는 경우에는 소스코드 파일이나 헤더파일도 재생성됩니다. 당연히 그에 대한 적절한 규칙을 미리 작성해두어야겠지만요.

오브젝트 파일들에 대한 재컴파일 작업이 끝나면 마지막으로 *make* 는 *edit* 실행파일에 대한 재링크 여부를 결정하게 됩니다.
만약 *edit* 파일이 존재하지 않거나 오브젝트 파일들 중 하나라도 *edit* 파일보다 최근에 생성된 파일이 있다면 *make* 는 모든 오브젝트 파일을 다시 링크시켜 *edit* 실행파일을 재생성시킵니다.
참고로 만약 위에서 오브젝트 파일이 하나라도 재컴파일되었었다면 그 시점에서 해당 오브젝트 파일이 *edit* 파일보다 최근에 생성된 것이 되므로 무조건 재링크가 수행되게 됩니다.

마지막으로 간단한 예로 이 절을 마무리하겠습니다.
만약 제가 *insert.c* 파일을 수정하고 *make* 를 실행시킨다면 *make* 는 *insert.c* 를 재컴파일하여 *insert.o* 파일을 만들고 곧이어 모든 오브젝트 파일들을 재링크하여 *edit* 이라는 실행파일을 만들어낼 것입니다.
또 만약 제가 *command.h* 라는 파일을 수정하고 *make* 를 실행시킨다면 *make* 는 *kbd.o*, *command.o*, *files.o* 를 재컴파일하여 만들고 다시 모든 오브젝트 파일들을 재링크하여 *edit* 이라는 실행파일을 만들 것이고요.
쉽죠?

## 2.4 반복작업이 싫다면 변수를! - Variables Make Makefiles Simpler
위 예제 *makefile* 의 규칙 *edit* 을 보면 모든 오브젝트 파일들을 두 번씩 써놓았습니다.
```
edit : main.o kbd.o command.o display.o \
              insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
```
이렇게 파일들을 중복해서 적어놓으면 나중에 파일을 추가하는 일이 생겼을 때 문제가 될 수 있습니다.
만약 프로젝트에 새로운 오브젝트 파일이 추가되었는데 이를 위쪽의 전제조건에만 적어두고
아래의 레시피에는 적지 않는다면 어떻게 될까요? 당연히 컴파일 과정에서 에러가 발생할 것입니다.
이렇듯 동일한 요소의 중복기술은 다양한 에러를 일으킵니다.
*makefile* 에서는 이러한 중복기술을 피하기 위하여 *변수(variable)* 라는 개념을 지원합니다.
변수에 문자열을 한 번만 정의하고 이후 문자열 대신 변수를 사용함으로써 문자열의 중복기술로 발생하는 에러를 미리 방지할 수 있습니다.
자세한 내용은 [How to Use Variables](https://www.gnu.org/software/make/manual/make.html#Using-Variables)를 참고해주세요.

*makefile* 에서는 오브젝트 파일들을 저장하는 변수에 관습적으로 *objects*, *OBJECTS*, *objs*, *OBJS*, *obj*, *OBJ* 같은 이름들을 붙입니다.
이번 예제에서 우리는 *objects* 라는 이름을 사용해보겠습니다.
```
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
```
이러면 이제 오브젝트 파일들을 일일이 나열하는 대신에 '*$(objects)*' 라고만 써도 같은 효과를 볼 수가 있습니다 ([How to Use Variables](https://www.gnu.org/software/make/manual/make.html#Using-Variables)참고).

이제 이걸 저 위에서 작성한 예제 *makefile* 에 적용하면
```
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
```
이 됩니다.

## 2.5 레시피 생략하기 - Letting *make* Deduce the Recipes
사실은 *makefile* 에 모든 레시피를 일일이 작성할 필요가 없습니다.
*make* 에는 묵시적으로 정의되어 있는 *묵시적 규칙(implicit rule)* 이라는 특별한 규칙이 있는데
*make* 가 이 묵시적 규칙을 이용하여 적절한 레시피를 알아서 실행시켜주기도 하거든요.
대표적으로 '*.o*' 파일을 업데이트하기 위해 같은 이름의 '*.c*' 파일을 '*cc -c*' 명령어로 컴파일하는 묵시적 규칙이 있습니다.
만약 *main.o* 파일을 업데이트하는데 이 묵시적 규칙이 사용된다면 '*cc -c main.c -o main.o*' 명령어가 자동으로 실행되어 main.o 를 재생성하게 되는 것이죠.
이렇게 묵시적 규칙을 이용하여 적절한 컴파일 명령어를 실행시킬 수가 있기 때문에 오브젝트 파일 규칙들에서 레시피를 생략할 수가 있게 됩니다.
자세한 내용은 [Using Implicit Rules](https://www.gnu.org/software/make/manual/make.html#Implicit-Rules)를 참고해주세요.

이렇게 묵시적 규칙으로 '*.c*' 파일이 컴파일에 사용될 경우 이 '*.c*' 파일은 전제조건에도 자동으로 추가됩니다.
그래서 결국 레시피 뿐만 아니라 전제조건에서의 '*.c*' 파일도 생략할 수가 있게 됩니다.

이제까지 설명한 모든 내용을 반영하여 예제 *makefile* 을 다시 작성해보겠습니다.
```
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        rm edit $(objects)
```
조금 복잡해보일 수 있지만 앞으로 이러한 형식의 *makefile* 을 자주 사용하게 될 것입니다.
('*clean*'에 대해서는 이후의 장들에서 보다 자세히 설명하겠습니다.
[Phony Targets](https://www.gnu.org/software/make/manual/make.html#Phony-Targets)와 [Errors in Recipes](https://www.gnu.org/software/make/manual/make.html#Errors)에서 자세히 다루니 이를 참고해주세요)

이번 절에서 묵시적 규칙을 사용하면 *makefile* 작성이 훨씬 쉽고 간편해진다는 것을 볼 수 있었습니다.
그런만큼 중요하고 앞으로도 자주 보게 될 테니 금방 익숙해질 수 있을 겁니다.

## 2.6 다른 방식으로 *Makefile* 작성해보기 - Another Style of Makefile
만약 오브젝트 파일들을 묵시적 규칙만을 이용해서 컴파일하는 경우 *makefile* 을 이제까지와는 조금 다른 방법으로 작성할 수도 있습니다.
이 경우에 타겟을 기준으로 전제조건들을 묶음 짓는 게 아니라 전제조건을 기준으로 타겟을 묶음 짓게 됩니다.
```
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
```
여기에서 *defs.h* 는 모든 오브젝트 파일들의 전제조건이고 *command.h* 와 *buffer.h* 는 각각 3개, 4개 오브젝트 파일의 전제조건이 됩니다.

파일들을 타겟을 기준으로 묶음 짓든지 전제조건을 기준으로 묶음 짓든지는 취향문제입니다. 둘 중 무엇이 더 옳고 그를 것도 없고 확연히 더 좋은 것도 없습니다.
전제조건을 기준으로 묶음 짓는 것이 *makefile* 을 더 작고 압축적으로 작성한다는 데에서 강점이 있지만, 타겟을 기준으로 묶음 짓는 것도 특정 타겟의 종속성을 한 번에 볼 수 있다는 데에서 직관적이라는 장점이 있습니다.
결국 여러분이 원하는 방식을 선택해서 사용하면 됩니다.

## 2.7 디렉토리 청소하기 - Rules for Cleaning the Directory
